



  
    The Go Programming Language Specification
    
  



  Version of Jan 14, 2020










Introduction


This is a reference manual for the Go programming language. For
more information and other documents, see golang.org.



Go is a general-purpose language designed with systems programming
in mind. It is strongly typed and garbage-collected and has explicit
support for concurrent programming.  Programs are constructed from
packages, whose properties allow efficient management of
dependencies.



The grammar is compact and simple to parse, allowing for easy analysis
by automatic tools such as integrated development environments.


Notation

The syntax is specified using Extended Backus-Naur Form (EBNF):





Productions are expressions constructed from terms and the following
operators, in increasing precedence:




Lower-case production names are used to identify lexical tokens.
Non-terminals are in CamelCase. Lexical tokens are enclosed in
double quotes  or back quotes .



The form  represents the set of characters from
 through  as alternatives. The horizontal
ellipsis  is also used elsewhere in the spec to informally denote various
enumerations or code snippets that are not further specified. The character 
(as opposed to the three characters ) is not a token of the Go
language.


Source code representation


Source code is Unicode text encoded in
UTF-8. The text is not
canonicalized, so a single accented code point is distinct from the
same character constructed from combining an accent and a letter;
those are treated as two code points.  For simplicity, this document
will use the unqualified term character to refer to a Unicode code point
in the source text.


Each code point is distinct; for instance, upper and lower case letters
are different characters.


Implementation restriction: For compatibility with other tools, a
compiler may disallow the NUL character (U+0000) in the source text.


Implementation restriction: For compatibility with other tools, a
compiler may ignore a UTF-8-encoded byte order mark
(U+FEFF) if it is the first Unicode code point in the source text.
A byte order mark may be disallowed anywhere else in the source.


Characters


The following terms are used to denote specific Unicode character classes:




In The Unicode Standard 8.0,
Section 4.5 "General Category" defines a set of character categories.
Go treats all characters in any of the Letter categories Lu, Ll, Lt, Lm, or Lo
as Unicode letters, and those in the Number category Nd as Unicode digits.


Letters and digits


The underscore character  (U+005F) is considered a letter.



Lexical elements

Comments


Comments serve as program documentation. There are two forms:




Line comments start with the character sequence 
and stop at the end of the line.


General comments start with the character sequence 
and stop with the first subsequent character sequence .




A comment cannot start inside a rune or
string literal, or inside a comment.
A general comment containing no newlines acts like a space.
Any other comment acts like a newline.


Tokens


Tokens form the vocabulary of the Go language.
There are four classes: identifiers, keywords, operators
and punctuation, and literals.  White space, formed from
spaces (U+0020), horizontal tabs (U+0009),
carriage returns (U+000D), and newlines (U+000A),
is ignored except as it separates tokens
that would otherwise combine into a single token. Also, a newline or end of file
may trigger the insertion of a semicolon.
While breaking the input into tokens,
the next token is the longest sequence of characters that form a
valid token.


Semicolons


The formal grammar uses semicolons  as terminators in
a number of productions. Go programs may omit most of these semicolons
using the following two rules:




When the input is broken into tokens, a semicolon is automatically inserted
into the token stream immediately after a line's final token if that token is

	an
	    identifier
	

	an
	    integer,
	    floating-point,
	    imaginary,
	    rune, or
	    string literal
	

	one of the keywords
	    ,
	    ,
	    , or
	    
	

	one of the operators and punctuation
	    ,
	    ,
	    ,
	    , or
	    
	




To allow complex statements to occupy a single line, a semicolon
may be omitted before a closing  or .




To reflect idiomatic use, code examples in this document elide semicolons
using these rules.



Identifiers


Identifiers name program entities such as variables and types.
An identifier is a sequence of one or more letters and digits.
The first character in an identifier must be a letter.





Some identifiers are predeclared.



Keywords


The following keywords are reserved and may not be used as identifiers.



Operators and punctuation


The following character sequences represent operators
(including assignment operators) and punctuation:



Integer literals


An integer literal is a sequence of digits representing an
integer constant.
An optional prefix sets a non-decimal base:  or 
for binary, , , or  for octal,
and  or  for hexadecimal.
A single  is considered a decimal zero.
In hexadecimal literals, letters  through 
and  through  represent values 10 through 15.



For readability, an underscore character  may appear after
a base prefix or between successive digits; such underscores do not change
the literal's value.






Floating-point literals


A floating-point literal is a decimal or hexadecimal representation of a
floating-point constant.



A decimal floating-point literal consists of an integer part (decimal digits),
a decimal point, a fractional part (decimal digits), and an exponent part
( or  followed by an optional sign and decimal digits).
One of the integer part or the fractional part may be elided; one of the decimal point
or the exponent part may be elided.
An exponent value exp scales the mantissa (integer and fractional part) by 10exp.



A hexadecimal floating-point literal consists of a  or 
prefix, an integer part (hexadecimal digits), a radix point, a fractional part (hexadecimal digits),
and an exponent part ( or  followed by an optional sign and decimal digits).
One of the integer part or the fractional part may be elided; the radix point may be elided as well,
but the exponent part is required. (This syntax matches the one given in IEEE 754-2008 §5.12.3.)
An exponent value exp scales the mantissa (integer and fractional part) by 2exp.



For readability, an underscore character  may appear after
a base prefix or between successive digits; such underscores do not change
the literal value.







Imaginary literals


An imaginary literal represents the imaginary part of a
complex constant.
It consists of an integer or
floating-point literal
followed by the lower-case letter .
The value of an imaginary literal is the value of the respective
integer or floating-point literal multiplied by the imaginary unit i.





For backward compatibility, an imaginary literal's integer part consisting
entirely of decimal digits (and possibly underscores) is considered a decimal
integer, even if it starts with a leading .





Rune literals


A rune literal represents a rune constant,
an integer value identifying a Unicode code point.
A rune literal is expressed as one or more characters enclosed in single quotes,
as in  or .
Within the quotes, any character may appear except newline and unescaped single
quote. A single quoted character represents the Unicode value
of the character itself,
while multi-character sequences beginning with a backslash encode
values in various formats.



The simplest form represents the single character within the quotes;
since Go source text is Unicode characters encoded in UTF-8, multiple
UTF-8-encoded bytes may represent a single integer value.  For
instance, the literal  holds a single byte representing
a literal , Unicode U+0061, value , while
 holds two bytes ( ) representing
a literal -dieresis, U+00E4, value .



Several backslash escapes allow arbitrary values to be encoded as
ASCII text.  There are four ways to represent the integer value
as a numeric constant:  followed by exactly two hexadecimal
digits;  followed by exactly four hexadecimal digits;
 followed by exactly eight hexadecimal digits, and a
plain backslash  followed by exactly three octal digits.
In each case the value of the literal is the value represented by
the digits in the corresponding base.



Although these representations all result in an integer, they have
different valid ranges.  Octal escapes must represent a value between
0 and 255 inclusive.  Hexadecimal escapes satisfy this condition
by construction. The escapes  and 
represent Unicode code points so within them some values are illegal,
in particular those above  and surrogate halves.



After a backslash, certain single-character escapes represent special values:





All other sequences starting with a backslash are illegal inside rune literals.






String literals


A string literal represents a string constant
obtained from concatenating a sequence of characters. There are two forms:
raw string literals and interpreted string literals.



Raw string literals are character sequences between back quotes, as in
.  Within the quotes, any character may appear except
back quote. The value of a raw string literal is the
string composed of the uninterpreted (implicitly UTF-8-encoded) characters
between the quotes;
in particular, backslashes have no special meaning and the string may
contain newlines.
Carriage return characters ('\r') inside raw string literals
are discarded from the raw string value.



Interpreted string literals are character sequences between double
quotes, as in .
Within the quotes, any character may appear except newline and unescaped double quote.
The text between the quotes forms the
value of the literal, with backslash escapes interpreted as they
are in rune literals (except that  is illegal and
 is legal), with the same restrictions.
The three-digit octal (nnn)
and two-digit hexadecimal (nn) escapes represent individual
bytes of the resulting string; all other escapes represent
the (possibly multi-byte) UTF-8 encoding of individual characters.
Thus inside a string literal  and  represent
a single byte of value =255, while ,
,  and  represent
the two bytes   of the UTF-8 encoding of character
U+00FF.







These examples all represent the same string:





If the source code represents a character as two code points, such as
a combining form involving an accent and a letter, the result will be
an error if placed in a rune literal (it is not a single code
point), and will appear as two code points if placed in a string
literal.



Constants

There are boolean constants,
rune constants,
integer constants,
floating-point constants, complex constants,
and string constants. Rune, integer, floating-point,
and complex constants are
collectively called numeric constants.



A constant value is represented by a
rune,
integer,
floating-point,
imaginary,
or
string literal,
an identifier denoting a constant,
a constant expression,
a conversion with a result that is a constant, or
the result value of some built-in functions such as
 applied to any value,
 or  applied to
some expressions,
 and  applied to a complex constant
and  applied to numeric constants.
The boolean truth values are represented by the predeclared constants
 and . The predeclared identifier
iota denotes an integer constant.



In general, complex constants are a form of
constant expression
and are discussed in that section.



Numeric constants represent exact values of arbitrary precision and do not overflow.
Consequently, there are no constants denoting the IEEE-754 negative zero, infinity,
and not-a-number values.



Constants may be typed or untyped.
Literal constants, , , ,
and certain constant expressions
containing only untyped constant operands are untyped.



A constant may be given a type explicitly by a constant declaration
or conversion, or implicitly when used in a
variable declaration or an
assignment or as an
operand in an expression.
It is an error if the constant value
cannot be represented as a value of the respective type.



An untyped constant has a default type which is the type to which the
constant is implicitly converted in contexts where a typed value is required,
for instance, in a short variable declaration
such as  where there is no explicit type.
The default type of an untyped constant is , ,
, ,  or 
respectively, depending on whether it is a boolean, rune, integer, floating-point,
complex, or string constant.



Implementation restriction: Although numeric constants have arbitrary
precision in the language, a compiler may implement them using an
internal representation with limited precision.  That said, every
implementation must:



	Represent integer constants with at least 256 bits.

	Represent floating-point constants, including the parts of
	    a complex constant, with a mantissa of at least 256 bits
	    and a signed binary exponent of at least 16 bits.

	Give an error if unable to represent an integer constant
	    precisely.

	Give an error if unable to represent a floating-point or
	    complex constant due to overflow.

	Round to the nearest representable constant if unable to
	    represent a floating-point or complex constant due to limits
	    on precision.



These requirements apply both to literal constants and to the result
of evaluating constant
expressions.



Variables


A variable is a storage location for holding a value.
The set of permissible values is determined by the
variable's type.



A variable declaration
or, for function parameters and results, the signature
of a function declaration
or function literal reserves
storage for a named variable.

Calling the built-in function 
or taking the address of a composite literal
allocates storage for a variable at run time.
Such an anonymous variable is referred to via a (possibly implicit)
pointer indirection.



Structured variables of array, slice,
and struct types have elements and fields that may
be addressed individually. Each such element
acts like a variable.



The static type (or just type) of a variable is the
type given in its declaration, the type provided in the
 call or composite literal, or the type of
an element of a structured variable.
Variables of interface type also have a distinct dynamic type,
which is the concrete type of the value assigned to the variable at run time
(unless the value is the predeclared identifier ,
which has no type).
The dynamic type may vary during execution but values stored in interface
variables are always assignable
to the static type of the variable.





A variable's value is retrieved by referring to the variable in an
expression; it is the most recent value
assigned to the variable.
If a variable has not yet been assigned a value, its value is the
zero value for its type.



Types


A type determines a set of values together with operations and methods specific
to those values. A type may be denoted by a type name, if it has one,
or specified using a type literal, which composes a type from existing types.





The language predeclares certain type names.
Others are introduced with type declarations.
Composite types—array, struct, pointer, function,
interface, slice, map, and channel types—may be constructed using
type literals.



Each type  has an underlying type: If 
is one of the predeclared boolean, numeric, or string types, or a type literal,
the corresponding underlying
type is  itself. Otherwise, 's underlying type
is the underlying type of the type to which  refers in its
type declaration.





The underlying type of , , , ,
and  is .
The underlying type of , , and  is .


Method sets

A type may have a method set associated with it.
The method set of an interface type is its interface.
The method set of any other type  consists of all
methods declared with receiver type .
The method set of the corresponding pointer type 
is the set of all methods declared with receiver  or 
(that is, it also contains the method set of ).
Further rules apply to structs containing embedded fields, as described
in the section on struct types.
Any other type has an empty method set.
In a method set, each method must have a
unique
non-blank method name.



The method set of a type determines the interfaces that the
type implements
and the methods that can be called
using a receiver of that type.


Boolean types


A boolean type represents the set of Boolean truth values
denoted by the predeclared constants 
and . The predeclared boolean type is ;
it is a defined type.


Numeric types


A numeric type represents sets of integer or floating-point values.
The predeclared architecture-independent numeric types are:





The value of an n-bit integer is n bits wide and represented using
two's complement arithmetic.



There is also a set of predeclared numeric types with implementation-specific sizes:





To avoid portability issues all numeric types are defined
types and thus distinct except
, which is an alias for , and
, which is an alias for .
Explicit conversions
are required when different numeric types are mixed in an expression
or assignment. For instance,  and 
are not the same type even though they may have the same size on a
particular architecture.


String types


A string type represents the set of string values.
A string value is a (possibly empty) sequence of bytes.
The number of bytes is called the length of the string and is never negative.
Strings are immutable: once created,
it is impossible to change the contents of a string.
The predeclared string type is ;
it is a defined type.



The length of a string  can be discovered using
the built-in function .
The length is a compile-time constant if the string is a constant.
A string's bytes can be accessed by integer indices
0 through .
It is illegal to take the address of such an element; if
 is the 'th byte of a
string,  is invalid.



Array types


An array is a numbered sequence of elements of a single
type, called the element type.
The number of elements is called the length of the array and is never negative.





The length is part of the array's type; it must evaluate to a
non-negative constant
representable by a value
of type .
The length of array  can be discovered
using the built-in function .
The elements can be addressed by integer indices
0 through .
Array types are always one-dimensional but may be composed to form
multi-dimensional types.




Slice types


A slice is a descriptor for a contiguous segment of an underlying array and
provides access to a numbered sequence of elements from that array.
A slice type denotes the set of all slices of arrays of its element type.
The number of elements is called the length of the slice and is never negative.
The value of an uninitialized slice is .





The length of a slice  can be discovered by the built-in function
; unlike with arrays it may change during
execution.  The elements can be addressed by integer indices
0 through .  The slice index of a
given element may be less than the index of the same element in the
underlying array.


A slice, once initialized, is always associated with an underlying
array that holds its elements.  A slice therefore shares storage
with its array and with other slices of the same array; by contrast,
distinct arrays always represent distinct storage.


The array underlying a slice may extend past the end of the slice.
The capacity is a measure of that extent: it is the sum of
the length of the slice and the length of the array beyond the slice;
a slice of length up to that capacity can be created by
slicing a new one from the original slice.
The capacity of a slice  can be discovered using the
built-in function .



A new, initialized slice value for a given element type  is
made using the built-in function
,
which takes a slice type
and parameters specifying the length and optionally the capacity.
A slice created with  always allocates a new, hidden array
to which the returned slice value refers. That is, executing





produces the same slice as allocating an array and slicing
it, so these two expressions are equivalent:





Like arrays, slices are always one-dimensional but may be composed to construct
higher-dimensional objects.
With arrays of arrays, the inner arrays are, by construction, always the same length;
however with slices of slices (or arrays of slices), the inner lengths may vary dynamically.
Moreover, the inner slices must be initialized individually.


Struct types


A struct is a sequence of named elements, called fields, each of which has a
name and a type. Field names may be specified explicitly (IdentifierList) or
implicitly (EmbeddedField).
Within a struct, non-blank field names must
be unique.







A field declared with a type but no explicit field name is called an embedded field.
An embedded field must be specified as
a type name  or as a pointer to a non-interface type name ,
and  itself may not be
a pointer type. The unqualified type name acts as the field name.





The following declaration is illegal because field names must be unique
in a struct type:





A field or method  of an
embedded field in a struct  is called promoted if
 is a legal selector that denotes
that field or method .



Promoted fields act like ordinary fields
of a struct except that they cannot be used as field names in
composite literals of the struct.



Given a struct type  and a defined type
, promoted methods are included in the method set of the struct as follows:


	
	If  contains an embedded field ,
	the method sets of 
	and  both include promoted methods with receiver
	. The method set of  also
	includes promoted methods with receiver .
	

	
	If  contains an embedded field ,
	the method sets of  and  both
	include promoted methods with receiver  or
	.
	



A field declaration may be followed by an optional string literal tag,
which becomes an attribute for all the fields in the corresponding
field declaration. An empty tag string is equivalent to an absent tag.
The tags are made visible through a reflection interface
and take part in type identity for structs
but are otherwise ignored.




Pointer types


A pointer type denotes the set of all pointers to variables of a given
type, called the base type of the pointer.
The value of an uninitialized pointer is .






Function types


A function type denotes the set of all functions with the same parameter
and result types. The value of an uninitialized variable of function type
is .





Within a list of parameters or results, the names (IdentifierList)
must either all be present or all be absent. If present, each name
stands for one item (parameter or result) of the specified type and
all non-blank names in the signature
must be unique.
If absent, each type stands for one item of that type.
Parameter and result
lists are always parenthesized except that if there is exactly
one unnamed result it may be written as an unparenthesized type.



The final incoming parameter in a function signature may have
a type prefixed with .
A function with such a parameter is called variadic and
may be invoked with zero or more arguments for that parameter.





Interface types


An interface type specifies a method set called its interface.
A variable of interface type can store a value of any type with a method set
that is any superset of the interface. Such a type is said to
implement the interface.
The value of an uninitialized variable of interface type is .





An interface type may specify methods explicitly through method specifications,
or it may embed methods of other interfaces through interface type names.





The name of each explicitly specified method must be unique
and not blank.





More than one type may implement an interface.
For instance, if two types  and 
have the method set





(where  stands for either  or )
then the  interface is implemented by both  and
, regardless of what other methods
 and  may have or share.



A type implements any interface comprising any subset of its methods
and may therefore implement several distinct interfaces. For
instance, all types implement the empty interface:





Similarly, consider this interface specification,
which appears within a type declaration
to define an interface called :





If  and  also implement





they implement the  interface as well
as the  interface.



An interface  may use a (possibly qualified) interface type
name  in place of a method specification. This is called
embedding interface  in .
The method set of  is the union
of the method sets of ’s explicitly declared methods and of
’s embedded interfaces.





A union of method sets contains the (exported and non-exported)
methods of each method set exactly once, and methods with the
same names must
have identical signatures.





An interface type  may not embed itself
or any interface type that embeds , recursively.




Map types


A map is an unordered group of elements of one type, called the
element type, indexed by a set of unique keys of another type,
called the key type.
The value of an uninitialized map is .





The comparison operators
 and  must be fully defined
for operands of the key type; thus the key type must not be a function, map, or
slice.
If the key type is an interface type, these
comparison operators must be defined for the dynamic key values;
failure will cause a run-time panic.






The number of map elements is called its length.
For a map , it can be discovered using the
built-in function 
and may change during execution. Elements may be added during execution
using assignments and retrieved with
index expressions; they may be removed with the
 built-in function.


A new, empty map value is made using the built-in
function ,
which takes the map type and an optional capacity hint as arguments:





The initial capacity does not bound its size:
maps grow to accommodate the number of items
stored in them, with the exception of  maps.
A  map is equivalent to an empty map except that no elements
may be added.

Channel types


A channel provides a mechanism for
concurrently executing functions
to communicate by
sending and
receiving
values of a specified element type.
The value of an uninitialized channel is .





The optional  operator specifies the channel direction,
send or receive. If no direction is given, the channel is
bidirectional.
A channel may be constrained only to send or only to receive by
assignment or
explicit conversion.





The  operator associates with the leftmost 
possible:





A new, initialized channel
value can be made using the built-in function
,
which takes the channel type and an optional capacity as arguments:





The capacity, in number of elements, sets the size of the buffer in the channel.
If the capacity is zero or absent, the channel is unbuffered and communication
succeeds only when both a sender and receiver are ready. Otherwise, the channel
is buffered and communication succeeds without blocking if the buffer
is not full (sends) or not empty (receives).
A  channel is never ready for communication.



A channel may be closed with the built-in function
.
The multi-valued assignment form of the
receive operator
reports whether a received value was sent before
the channel was closed.



A single channel may be used in
send statements,
receive operations,
and calls to the built-in functions
 and

by any number of goroutines without further synchronization.
Channels act as first-in-first-out queues.
For example, if one goroutine sends values on a channel
and a second goroutine receives them, the values are
received in the order sent.


Properties of types and values

Type identity


Two types are either identical or different.



A defined type is always different from any other type.
Otherwise, two types are identical if their underlying type literals are
structurally equivalent; that is, they have the same literal structure and corresponding
components have identical types. In detail:



	Two array types are identical if they have identical element types and
	    the same array length.

	Two slice types are identical if they have identical element types.

	Two struct types are identical if they have the same sequence of fields,
	    and if corresponding fields have the same names, and identical types,
	    and identical tags.
	    Non-exported field names from different
	    packages are always different.

	Two pointer types are identical if they have identical base types.

	Two function types are identical if they have the same number of parameters
	    and result values, corresponding parameter and result types are
	    identical, and either both functions are variadic or neither is.
	    Parameter and result names are not required to match.

	Two interface types are identical if they have the same set of methods
	    with the same names and identical function types.
	    Non-exported method names from different
	    packages are always different. The order of the methods is irrelevant.

	Two map types are identical if they have identical key and element types.

	Two channel types are identical if they have identical element types and
	    the same direction.



Given the declarations





these types are identical:





 and  are different because they are new types
created by distinct type definitions;
 and 
are different because  is different from .



Assignability


A value  is assignable to a variable of type 
(" is assignable to ") if one of the following conditions applies:




's type is identical to .


's type  and  have identical
underlying types and at least one of 
or  is not a defined type.


 is an interface type and
 implements .


 is a bidirectional channel value,  is a channel type,
's type  and  have identical element types,
and at least one of  or  is not a defined type.


 is the predeclared identifier  and 
is a pointer, function, slice, map, channel, or interface type.


 is an untyped constant
representable
by a value of type .




Representability


A constant  is representable
by a value of type  if one of the following conditions applies:




 is in the set of values determined by .



 is a floating-point type and  can be rounded to 's
precision without overflow. Rounding uses IEEE 754 round-to-even rules but with an IEEE
negative zero further simplified to an unsigned zero. Note that constant values never result
in an IEEE negative zero, NaN, or infinity.



 is a complex type, and 's
components  and 
are representable by values of 's component type ( or
).








Blocks


A block is a possibly empty sequence of declarations and statements
within matching brace brackets.





In addition to explicit blocks in the source code, there are implicit blocks:



	The universe block encompasses all Go source text.

	Each package has a package block containing all
	    Go source text for that package.

	Each file has a file block containing all Go source text
	    in that file.

	Each "if",
	    "for", and
	    "switch"
	    statement is considered to be in its own implicit block.

	Each clause in a "switch"
	    or "select" statement
	    acts as an implicit block.



Blocks nest and influence scoping.



Declarations and scope


A declaration binds a non-blank identifier to a
constant,
type,
variable,
function,
label, or
package.
Every identifier in a program must be declared.
No identifier may be declared twice in the same block, and
no identifier may be declared in both the file and package block.



The blank identifier may be used like any other identifier
in a declaration, but it does not introduce a binding and thus is not declared.
In the package block, the identifier  may only be used for
 function declarations,
and like the blank identifier it does not introduce a new binding.





The scope of a declared identifier is the extent of source text in which
the identifier denotes the specified constant, type, variable, function, label, or package.



Go is lexically scoped using blocks:



	The scope of a predeclared identifier is the universe block.

	The scope of an identifier denoting a constant, type, variable,
	    or function (but not method) declared at top level (outside any
	    function) is the package block.

	The scope of the package name of an imported package is the file block
	    of the file containing the import declaration.

	The scope of an identifier denoting a method receiver, function parameter,
	    or result variable is the function body.

	The scope of a constant or variable identifier declared
	    inside a function begins at the end of the ConstSpec or VarSpec
	    (ShortVarDecl for short variable declarations)
	    and ends at the end of the innermost containing block.

	The scope of a type identifier declared inside a function
	    begins at the identifier in the TypeSpec
	    and ends at the end of the innermost containing block.



An identifier declared in a block may be redeclared in an inner block.
While the identifier of the inner declaration is in scope, it denotes
the entity declared by the inner declaration.



The package clause is not a declaration; the package name
does not appear in any scope. Its purpose is to identify the files belonging
to the same package and to specify the default package name for import
declarations.



Label scopes


Labels are declared by labeled statements and are
used in the "break",
"continue", and
"goto" statements.
It is illegal to define a label that is never used.
In contrast to other identifiers, labels are not block scoped and do
not conflict with identifiers that are not labels. The scope of a label
is the body of the function in which it is declared and excludes
the body of any nested function.



Blank identifier


The blank identifier is represented by the underscore character .
It serves as an anonymous placeholder instead of a regular (non-blank)
identifier and has special meaning in declarations,
as an operand, and in assignments.



Predeclared identifiers


The following identifiers are implicitly declared in the
universe block:




Exported identifiers


An identifier may be exported to permit access to it from another package.
An identifier is exported if both:


	the first character of the identifier's name is a Unicode upper case
	letter (Unicode class "Lu"); and
	the identifier is declared in the package block
	or it is a field name or
	method name.


All other identifiers are not exported.



Uniqueness of identifiers


Given a set of identifiers, an identifier is called unique if it is
different from every other in the set.
Two identifiers are different if they are spelled differently, or if they
appear in different packages and are not
exported. Otherwise, they are the same.


Constant declarations


A constant declaration binds a list of identifiers (the names of
the constants) to the values of a list of constant expressions.
The number of identifiers must be equal
to the number of expressions, and the nth identifier on
the left is bound to the value of the nth expression on the
right.





If the type is present, all constants take the type specified, and
the expressions must be assignable to that type.
If the type is omitted, the constants take the
individual types of the corresponding expressions.
If the expression values are untyped constants,
the declared constants remain untyped and the constant identifiers
denote the constant values. For instance, if the expression is a
floating-point literal, the constant identifier denotes a floating-point
constant, even if the literal's fractional part is zero.





Within a parenthesized  declaration list the
expression list may be omitted from any but the first ConstSpec.
Such an empty list is equivalent to the textual substitution of the
first preceding non-empty expression list and its type if any.
Omitting the list of expressions is therefore equivalent to
repeating the previous list.  The number of identifiers must be equal
to the number of expressions in the previous list.
Together with the  constant generator
this mechanism permits light-weight declaration of sequential values:





Iota


Within a constant declaration, the predeclared identifier
 represents successive untyped integer 
constants. Its value is the index of the respective ConstSpec
in that constant declaration, starting at zero.
It can be used to construct a set of related constants:





By definition, multiple uses of  in the same ConstSpec all have the same value:





This last example exploits the implicit repetition
of the last non-empty expression list.



Type declarations


A type declaration binds an identifier, the type name, to a type.
Type declarations come in two forms: alias declarations and type definitions.




Alias declarations


An alias declaration binds an identifier to the given type.





Within the scope of
the identifier, it serves as an alias for the type.





Type definitions


A type definition creates a new, distinct type with the same
underlying type and operations as the given type,
and binds an identifier to it.





The new type is called a defined type.
It is different from any other type,
including the type it is created from.





A defined type may have methods associated with it.
It does not inherit any methods bound to the given type,
but the method set
of an interface type or of elements of a composite type remains unchanged:





Type definitions may be used to define different boolean, numeric,
or string types and associate methods with them:





Variable declarations


A variable declaration creates one or more variables,
binds corresponding identifiers to them, and gives each a type and an initial value.







If a list of expressions is given, the variables are initialized
with the expressions following the rules for assignments.
Otherwise, each variable is initialized to its zero value.



If a type is present, each variable is given that type.
Otherwise, each variable is given the type of the corresponding
initialization value in the assignment.
If that value is an untyped constant, it is first implicitly
converted to its default type;
if it is an untyped boolean value, it is first implicitly converted to type .
The predeclared value  cannot be used to initialize a variable
with no explicit type.





Implementation restriction: A compiler may make it illegal to declare a variable
inside a function body if the variable is
never used.


Short variable declarations


A short variable declaration uses the syntax:





It is shorthand for a regular variable declaration
with initializer expressions but no types:







Unlike regular variable declarations, a short variable declaration may redeclare
variables provided they were originally declared earlier in the same block
(or the parameter lists if the block is the function body) with the same type,
and at least one of the non-blank variables is new.
As a consequence, redeclaration can only appear in a multi-variable short declaration.
Redeclaration does not introduce a new variable; it just assigns a new value to the original.





Short variable declarations may appear only inside functions.
In some contexts such as the initializers for
"if",
"for", or
"switch" statements,
they can be used to declare local temporary variables.


Function declarations


A function declaration binds an identifier, the function name,
to a function.





If the function's signature declares
result parameters, the function body's statement list must end in
a terminating statement.





A function declaration may omit the body. Such a declaration provides the
signature for a function implemented outside Go, such as an assembly routine.




Method declarations


A method is a function with a receiver.
A method declaration binds an identifier, the method name, to a method,
and associates the method with the receiver's base type.





The receiver is specified via an extra parameter section preceding the method
name. That parameter section must declare a single non-variadic parameter, the receiver.
Its type must be a defined type  or a
pointer to a defined type .  is called the receiver
base type. A receiver base type cannot be a pointer or interface type and
it must be defined in the same package as the method.
The method is said to be bound to its receiver base type and the method name
is visible only within selectors for type 
or .



A non-blank receiver identifier must be
unique in the method signature.
If the receiver's value is not referenced inside the body of the method,
its identifier may be omitted in the declaration. The same applies in
general to parameters of functions and methods.



For a base type, the non-blank names of methods bound to it must be unique.
If the base type is a struct type,
the non-blank method and field names must be distinct.



Given defined type , the declarations





bind the methods  and ,
with receiver type ,
to the base type .



The type of a method is the type of a function with the receiver as first
argument.  For instance, the method  has type





However, a function declared this way is not a method.



Expressions


An expression specifies the computation of a value by applying
operators and functions to operands.


Operands


Operands denote the elementary values in an expression. An operand may be a
literal, a (possibly qualified)
non-blank identifier denoting a
constant,
variable, or
function,
or a parenthesized expression.



The blank identifier may appear as an
operand only on the left-hand side of an assignment.




Qualified identifiers


A qualified identifier is an identifier qualified with a package name prefix.
Both the package name and the identifier must not be
blank.





A qualified identifier accesses an identifier in a different package, which
must be imported.
The identifier must be exported and
declared in the package block of that package.




Composite literals


Composite literals construct values for structs, arrays, slices, and maps
and create a new value each time they are evaluated.
They consist of the type of the literal followed by a brace-bound list of elements.
Each element may optionally be preceded by a corresponding key.





The LiteralType's underlying type must be a struct, array, slice, or map type
(the grammar enforces this constraint except when the type is given
as a TypeName).
The types of the elements and keys must be assignable
to the respective field, element, and key types of the literal type;
there is no additional conversion.
The key is interpreted as a field name for struct literals,
an index for array and slice literals, and a key for map literals.
For map literals, all elements must have a key. It is an error
to specify multiple elements with the same field name or
constant key value. For non-constant map keys, see the section on
evaluation order.



For struct literals the following rules apply:


	A key must be a field name declared in the struct type.
	
	An element list that does not contain any keys must
	    list an element for each struct field in the
	    order in which the fields are declared.
	
	If any element has a key, every element must have a key.
	
	An element list that contains keys does not need to
	    have an element for each struct field. Omitted fields
	    get the zero value for that field.
	
	A literal may omit the element list; such a literal evaluates
	    to the zero value for its type.
	
	It is an error to specify an element for a non-exported
	    field of a struct belonging to a different package.
	



Given the declarations




one may write





For array and slice literals the following rules apply:


	Each element has an associated integer index marking
	    its position in the array.
	
	An element with a key uses the key as its index. The
	    key must be a non-negative constant
	    representable by
	    a value of type ; and if it is typed
	    it must be of integer type.
	
	An element without a key uses the previous element's index plus one.
	    If the first element has no key, its index is zero.
	



Taking the address of a composite literal
generates a pointer to a unique variable initialized
with the literal's value.





Note that the zero value for a slice or map
type is not the same as an initialized but empty value of the same type.
Consequently, taking the address of an empty slice or map composite literal
does not have the same effect as allocating a new slice or map value with
new.





The length of an array literal is the length specified in the literal type.
If fewer elements than the length are provided in the literal, the missing
elements are set to the zero value for the array element type.
It is an error to provide elements with index values outside the index range
of the array. The notation  specifies an array length equal
to the maximum element index plus one.





A slice literal describes the entire underlying array literal.
Thus the length and capacity of a slice literal are the maximum
element index plus one. A slice literal has the form





and is shorthand for a slice operation applied to an array:





Within a composite literal of array, slice, or map type ,
elements or map keys that are themselves composite literals may elide the respective
literal type if it is identical to the element or key type of .
Similarly, elements or keys that are addresses of composite literals may elide
the  when the element or key type is .





A parsing ambiguity arises when a composite literal using the
TypeName form of the LiteralType appears as an operand between the
keyword and the opening brace of the block
of an "if", "for", or "switch" statement, and the composite literal
is not enclosed in parentheses, square brackets, or curly braces.
In this rare case, the opening brace of the literal is erroneously parsed
as the one introducing the block of statements. To resolve the ambiguity,
the composite literal must appear within parentheses.





Examples of valid array, slice, and map literals:





Function literals


A function literal represents an anonymous function.







A function literal can be assigned to a variable or invoked directly.





Function literals are closures: they may refer to variables
defined in a surrounding function. Those variables are then shared between
the surrounding function and the function literal, and they survive as long
as they are accessible.



Primary expressions


Primary expressions are the operands for unary and binary expressions.








Selectors


For a primary expression 
that is not a package name, the
selector expression





denotes the field or method  of the value 
(or sometimes ; see below).
The identifier  is called the (field or method) selector;
it must not be the blank identifier.
The type of the selector expression is the type of .
If  is a package name, see the section on
qualified identifiers.



A selector  may denote a field or method  of
a type , or it may refer
to a field or method  of a nested
embedded field of .
The number of embedded fields traversed
to reach  is called its depth in .
The depth of a field or method 
declared in  is zero.
The depth of a field or method  declared in
an embedded field  in  is the
depth of  in  plus one.



The following rules apply to selectors:




For a value  of type  or 
where  is not a pointer or interface type,
 denotes the field or method at the shallowest depth
in  where there
is such an .
If there is not exactly one 
with shallowest depth, the selector expression is illegal.



For a value  of type  where 
is an interface type,  denotes the actual method with name
 of the dynamic value of .
If there is no method with name  in the
method set of , the selector
expression is illegal.



As an exception, if the type of  is a defined
pointer type and  is a valid selector expression denoting a field
(but not a method),  is shorthand for .



In all other cases,  is illegal.



If  is of pointer type and has the value
 and  denotes a struct field,
assigning to or evaluating 
causes a run-time panic.



If  is of interface type and has the value
, calling or
evaluating the method 
causes a run-time panic.




For example, given the declarations:





one may write:





but the following is invalid:





Method expressions


If  is in the method set of type ,
 is a function that is callable as a regular function
with the same arguments as  prefixed by an additional
argument that is the receiver of the method.





Consider a struct type  with two methods,
, whose receiver is of type , and
, whose receiver is of type .





The expression





yields a function equivalent to  but
with an explicit receiver as its first argument; it has signature





That function may be called normally with an explicit receiver, so
these five invocations are equivalent:





Similarly, the expression





yields a function value representing  with signature





For a method with a value receiver, one can derive a function
with an explicit pointer receiver, so





yields a function value representing  with signature





Such a function indirects through the receiver to create a value
to pass as the receiver to the underlying method;
the method does not overwrite the value whose address is passed in
the function call.



The final case, a value-receiver function for a pointer-receiver method,
is illegal because pointer-receiver methods are not in the method set
of the value type.



Function values derived from methods are called with function call syntax;
the receiver is provided as the first argument to the call.
That is, given ,  is invoked
as  not .
To construct a function that binds the receiver, use a
function literal or
method value.



It is legal to derive a function value from a method of an interface type.
The resulting function takes an explicit receiver of that interface type.


Method values


If the expression  has static type  and
 is in the method set of type ,
 is called a method value.
The method value  is a function value that is callable
with the same arguments as a method call of .
The expression  is evaluated and saved during the evaluation of the
method value; the saved copy is then used as the receiver in any calls,
which may be executed later.



The type  may be an interface or non-interface type.



As in the discussion of method expressions above,
consider a struct type  with two methods,
, whose receiver is of type , and
, whose receiver is of type .





The expression





yields a function value of type





These two invocations are equivalent:





Similarly, the expression





yields a function value of type





As with selectors, a reference to a non-interface method with a value receiver
using a pointer will automatically dereference that pointer:  is equivalent to .



As with method calls, a reference to a non-interface method with a pointer receiver
using an addressable value will automatically take the address of that value:  is equivalent to .





Although the examples above use non-interface types, it is also legal to create a method value
from a value of interface type.





Index expressions


A primary expression of the form





denotes the element of the array, pointer to array, slice, string or map  indexed by .
The value  is called the index or map key, respectively.
The following rules apply:



If  is not a map:


	the index  must be of integer type or an untyped constant
	a constant index must be non-negative and
	    representable by a value of type 
	a constant index that is untyped is given type 
	the index  is in range if ,
	    otherwise it is out of range



For  of array type :


	a constant index must be in range
	if  is out of range at run time,
	    a run-time panic occurs
	 is the array element at index  and the type of
	     is the element type of 



For  of pointer to array type:


	 is shorthand for 



For  of slice type :


	if  is out of range at run time,
	    a run-time panic occurs
	 is the slice element at index  and the type of
	     is the element type of 



For  of string type:


	a constant index must be in range
	    if the string  is also constant
	if  is out of range at run time,
	    a run-time panic occurs
	 is the non-constant byte value at index  and the type of
	     is 
	 may not be assigned to



For  of map type :


	's type must be
	    assignable
	    to the key type of 
	if the map contains an entry with key ,
	     is the map element with key 
	    and the type of  is the element type of 
	if the map is  or does not contain such an entry,
	     is the zero value
	    for the element type of 



Otherwise  is illegal.



An index expression on a map  of type 
used in an assignment or initialization of the special form





yields an additional untyped boolean value. The value of  is
 if the key  is present in the map, and
 otherwise.



Assigning to an element of a  map causes a
run-time panic.



Slice expressions


Slice expressions construct a substring or slice from a string, array, pointer
to array, or slice. There are two variants: a simple form that specifies a low
and high bound, and a full form that also specifies a bound on the capacity.


Simple slice expressions


For a string, array, pointer to array, or slice , the primary expression





constructs a substring or slice. The indices  and
 select which elements of operand  appear
in the result. The result has indices starting at 0 and length equal to
 - .
After slicing the array 





the slice  has type , length 3, capacity 4, and elements





For convenience, any of the indices may be omitted. A missing 
index defaults to zero; a missing  index defaults to the length of the
sliced operand:





If  is a pointer to an array,  is shorthand for
.



For arrays or strings, the indices are in range if
 <=  <=  <= ,
otherwise they are out of range.
For slices, the upper index bound is the slice capacity  rather than the length.
A constant index must be non-negative and
representable by a value of type
; for arrays or constant strings, constant indices must also be in range.
If both indices are constant, they must satisfy .
If the indices are out of range at run time, a run-time panic occurs.



Except for untyped strings, if the sliced operand is a string or slice,
the result of the slice operation is a non-constant value of the same type as the operand.
For untyped string operands the result is a non-constant value of type .
If the sliced operand is an array, it must be addressable
and the result of the slice operation is a slice with the same element type as the array.



If the sliced operand of a valid slice expression is a  slice, the result
is a  slice. Otherwise, if the result is a slice, it shares its underlying
array with the operand.





Full slice expressions


For an array, pointer to array, or slice  (but not a string), the primary expression





constructs a slice of the same type, and with the same length and elements as the simple slice
expression . Additionally, it controls the resulting slice's capacity
by setting it to . Only the first index may be omitted; it defaults to 0.
After slicing the array 





the slice  has type , length 2, capacity 4, and elements





As for simple slice expressions, if  is a pointer to an array,
 is shorthand for .
If the sliced operand is an array, it must be addressable.



The indices are in range if ,
otherwise they are out of range.
A constant index must be non-negative and
representable by a value of type
; for arrays, constant indices must also be in range.
If multiple indices are constant, the constants that are present must be in range relative to each
other.
If the indices are out of range at run time, a run-time panic occurs.


Type assertions


For an expression  of interface type
and a type , the primary expression





asserts that  is not 
and that the value stored in  is of type .
The notation  is called a type assertion.


More precisely, if  is not an interface type,  asserts
that the dynamic type of  is identical
to the type .
In this case,  must implement the (interface) type of ;
otherwise the type assertion is invalid since it is not possible for 
to store a value of type .
If  is an interface type,  asserts that the dynamic type
of  implements the interface .


If the type assertion holds, the value of the expression is the value
stored in  and its type is . If the type assertion is false,
a run-time panic occurs.
In other words, even though the dynamic type of 
is known only at run time, the type of  is
known to be  in a correct program.





A type assertion used in an assignment or initialization of the special form





yields an additional untyped boolean value. The value of  is 
if the assertion holds. Otherwise it is  and the value of  is
the zero value for type .
No run-time panic occurs in this case.



Calls


Given an expression  of function type
,





calls  with arguments .
Except for one special case, arguments must be single-valued expressions
assignable to the parameter types of
 and are evaluated before the function is called.
The type of the expression is the result type
of .
A method invocation is similar but the method itself
is specified as a selector upon a value of the receiver type for
the method.





In a function call, the function value and arguments are evaluated in
the usual order.
After they are evaluated, the parameters of the call are passed by value to the function
and the called function begins execution.
The return parameters of the function are passed by value
back to the calling function when the function returns.



Calling a  function value
causes a run-time panic.



As a special case, if the return values of a function or method
 are equal in number and individually
assignable to the parameters of another function or method
, then the call 
will invoke  after binding the return values of
 to the parameters of  in order.  The call
of  must contain no parameters other than the call of ,
and  must have at least one return value.
If  has a final  parameter, it is
assigned the return values of  that remain after
assignment of regular parameters.





A method call  is valid if the method set
of (the type of)  contains  and the
argument list can be assigned to the parameter list of .
If  is addressable and 's method
set contains ,  is shorthand
for :





There is no distinct method type and there are no method literals.


Passing arguments to  parameters


If  is variadic with a final
parameter  of type , then within 
the type of  is equivalent to type .
If  is invoked with no actual arguments for ,
the value passed to  is .
Otherwise, the value passed is a new slice
of type  with a new underlying array whose successive elements
are the actual arguments, which all must be assignable
to . The length and capacity of the slice is therefore
the number of arguments bound to  and may differ for each
call site.



Given the function and calls




within ,  will have the value
 in the first call, and
 in the second.



If the final argument is assignable to a slice type , it is
passed unchanged as the value for a  parameter if the argument
is followed by . In this case no new slice is created.



Given the slice  and call





within ,  will have the same value as 
with the same underlying array.



Operators


Operators combine operands into expressions.





Comparisons are discussed elsewhere.
For other binary operators, the operand types must be identical
unless the operation involves shifts or untyped constants.
For operations involving constants only, see the section on
constant expressions.



Except for shift operations, if one operand is an untyped constant
and the other operand is not, the constant is implicitly converted
to the type of the other operand.



The right operand in a shift expression must have integer type
or be an untyped constant representable by a
value of type .
If the left operand of a non-constant shift expression is an untyped constant,
it is first implicitly converted to the type it would assume if the shift expression were
replaced by its left operand alone.





Operator precedence

Unary operators have the highest precedence.
As the   and  operators form
statements, not expressions, they fall
outside the operator hierarchy.
As a consequence, statement  is the same as .

There are five precedence levels for binary operators.
Multiplication operators bind strongest, followed by addition
operators, comparison operators,  (logical AND),
and finally  (logical OR):





Binary operators of the same precedence associate from left to right.
For instance,  is the same as .





Arithmetic operators

Arithmetic operators apply to numeric values and yield a result of the same
type as the first operand. The four standard arithmetic operators (,
, , ) apply to integer,
floating-point, and complex types;  also applies to strings.
The bitwise logical and shift operators apply to integers only.





Integer operators


For two integer values  and , the integer quotient
 and remainder  satisfy the following
relationships:





with  truncated towards zero
("truncated division").





The one exception to this rule is that if the dividend  is
the most negative value for the int type of , the quotient
 is equal to  (and )
due to two's-complement integer overflow:





If the divisor is a constant, it must not be zero.
If the divisor is zero at run time, a run-time panic occurs.
If the dividend is non-negative and the divisor is a constant power of 2,
the division may be replaced by a right shift, and computing the remainder may
be replaced by a bitwise AND operation:





The shift operators shift the left operand by the shift count specified by the
right operand, which must be non-negative. If the shift count is negative at run time,
a run-time panic occurs.
The shift operators implement arithmetic shifts if the left operand is a signed
integer and logical shifts if it is an unsigned integer.
There is no upper limit on the shift count. Shifts behave
as if the left operand is shifted  times by 1 for a shift
count of .
As a result,  is the same as 
and  is the same as
 but truncated towards negative infinity.



For integer operands, the unary operators
, , and  are defined as
follows:





Integer overflow


For unsigned integer values, the operations ,
, , and  are
computed modulo 2n, where n is the bit width of
the unsigned integer's type.
Loosely speaking, these unsigned integer operations
discard high bits upon overflow, and programs may rely on "wrap around".


For signed integers, the operations ,
, , , and  may legally
overflow and the resulting value exists and is deterministically defined
by the signed integer representation, the operation, and its operands.
Overflow does not cause a run-time panic.
A compiler may not optimize code under the assumption that overflow does
not occur. For instance, it may not assume that  is always true.



Floating-point operators


For floating-point and complex numbers,
 is the same as ,
while  is the negation of .
The result of a floating-point or complex division by zero is not specified beyond the
IEEE-754 standard; whether a run-time panic
occurs is implementation-specific.



An implementation may combine multiple floating-point operations into a single
fused operation, possibly across statements, and produce a result that differs
from the value obtained by executing and rounding the instructions individually.
An explicit floating-point type conversion rounds to
the precision of the target type, preventing fusion that would discard that rounding.



For instance, some architectures provide a "fused multiply and add" (FMA) instruction
that computes  without rounding the intermediate result .
These examples show when a Go implementation can use that instruction:




String concatenation


Strings can be concatenated using the  operator
or the  assignment operator:





String addition creates a new string by concatenating the operands.



Comparison operators


Comparison operators compare two operands and yield an untyped boolean value.





In any comparison, the first operand
must be assignable
to the type of the second operand, or vice versa.


The equality operators  and  apply
to operands that are comparable.
The ordering operators , , , and 
apply to operands that are ordered.
These terms and the result of the comparisons are defined as follows:



	
	Boolean values are comparable.
	Two boolean values are equal if they are either both
	 or both .
	

	
	Integer values are comparable and ordered, in the usual way.
	

	
	Floating-point values are comparable and ordered,
	as defined by the IEEE-754 standard.
	

	
	Complex values are comparable.
	Two complex values  and  are
	equal if both  and
	.
	

	
	String values are comparable and ordered, lexically byte-wise.
	

	
	Pointer values are comparable.
	Two pointer values are equal if they point to the same variable or if both have value .
	Pointers to distinct zero-size variables may or may not be equal.
	

	
	Channel values are comparable.
	Two channel values are equal if they were created by the same call to
	
	or if both have value .
	

	
	Interface values are comparable.
	Two interface values are equal if they have identical dynamic types
	and equal dynamic values or if both have value .
	

	
	A value  of non-interface type  and
	a value  of interface type  are comparable when values
	of type  are comparable and
	 implements .
	They are equal if 's dynamic type is identical to 
	and 's dynamic value is equal to .
	

	
	Struct values are comparable if all their fields are comparable.
	Two struct values are equal if their corresponding
	non-blank fields are equal.
	

	
	Array values are comparable if values of the array element type are comparable.
	Two array values are equal if their corresponding elements are equal.
	



A comparison of two interface values with identical dynamic types
causes a run-time panic if values
of that type are not comparable.  This behavior applies not only to direct interface
value comparisons but also when comparing arrays of interface values
or structs with interface-valued fields.



Slice, map, and function values are not comparable.
However, as a special case, a slice, map, or function value may
be compared to the predeclared identifier .
Comparison of pointer, channel, and interface values to 
is also allowed and follows from the general rules above.




Logical operators


Logical operators apply to boolean values
and yield a result of the same type as the operands.
The right operand is evaluated conditionally.





Address operators


For an operand  of type , the address operation
 generates a pointer of type  to .
The operand must be addressable,
that is, either a variable, pointer indirection, or slice indexing
operation; or a field selector of an addressable struct operand;
or an array indexing operation of an addressable array.
As an exception to the addressability requirement,  may also be a
(possibly parenthesized)
composite literal.
If the evaluation of  would cause a run-time panic,
then the evaluation of  does too.



For an operand  of pointer type , the pointer
indirection  denotes the variable of type  pointed
to by .
If  is , an attempt to evaluate 
will cause a run-time panic.





Receive operator


For an operand  of channel type,
the value of the receive operation  is the value received
from the channel . The channel direction must permit receive operations,
and the type of the receive operation is the element type of the channel.
The expression blocks until a value is available.
Receiving from a  channel blocks forever.
A receive operation on a closed channel can always proceed
immediately, yielding the element type's zero value
after any previously sent values have been received.





A receive expression used in an assignment or initialization of the special form





yields an additional untyped boolean result reporting whether the
communication succeeded. The value of  is 
if the value received was delivered by a successful send operation to the
channel, or  if it is a zero value generated because the
channel is closed and empty.



Conversions


A conversion changes the type of an expression
to the type specified by the conversion.
A conversion may appear literally in the source, or it may be implied
by the context in which an expression appears.



An explicit conversion is an expression of the form 
where  is a type and  is an expression
that can be converted to type .





If the type starts with the operator  or ,
or if the type starts with the keyword 
and has no result list, it must be parenthesized when
necessary to avoid ambiguity:





A constant value  can be converted to
type  if  is representable
by a value of .
As a special case, an integer constant  can be explicitly converted to a
string type using the
same rule
as for non-constant .



Converting a constant yields a typed constant as result.





A non-constant value  can be converted to type 
in any of these cases:



	
	 is assignable
	to .
	
	
	ignoring struct tags (see below),
	's type and  have identical
	underlying types.
	
	
	ignoring struct tags (see below),
	's type and  are pointer types
	that are not defined types,
	and their pointer base types have identical underlying types.
	
	
	's type and  are both integer or floating
	point types.
	
	
	's type and  are both complex types.
	
	
	 is an integer or a slice of bytes or runes
	and  is a string type.
	
	
	 is a string and  is a slice of bytes or runes.
	



Struct tags are ignored when comparing struct types
for identity for the purpose of conversion:





Specific rules apply to (non-constant) conversions between numeric types or
to and from a string type.
These conversions may change the representation of 
and incur a run-time cost.
All other conversions only change the type but not the representation
of .



There is no linguistic mechanism to convert between pointers and integers.
The package 
implements this functionality under
restricted circumstances.


Conversions between numeric types


For the conversion of non-constant numeric values, the following rules apply:




When converting between integer types, if the value is a signed integer, it is
sign extended to implicit infinite precision; otherwise it is zero extended.
It is then truncated to fit in the result type's size.
For example, if , then .
The conversion always yields a valid value; there is no indication of overflow.


When converting a floating-point number to an integer, the fraction is discarded
(truncation towards zero).


When converting an integer or floating-point number to a floating-point type,
or a complex number to another complex type, the result value is rounded
to the precision specified by the destination type.
For instance, the value of a variable  of type 
may be stored using additional precision beyond that of an IEEE-754 32-bit number,
but float32(x) represents the result of rounding 's value to
32-bit precision. Similarly,  may use more than 32 bits
of precision, but  does not.




In all non-constant conversions involving floating-point or complex values,
if the result type cannot represent the value the conversion
succeeds but the result value is implementation-dependent.


Conversions to and from a string type



Converting a signed or unsigned integer value to a string type yields a
string containing the UTF-8 representation of the integer. Values outside
the range of valid Unicode code points are converted to .





Converting a slice of bytes to a string type yields
a string whose successive bytes are the elements of the slice.





Converting a slice of runes to a string type yields
a string that is the concatenation of the individual rune values
converted to strings.





Converting a value of a string type to a slice of bytes type
yields a slice whose successive elements are the bytes of the string.





Converting a value of a string type to a slice of runes type
yields a slice containing the individual Unicode code points of the string.






Constant expressions


Constant expressions may contain only constant
operands and are evaluated at compile time.



Untyped boolean, numeric, and string constants may be used as operands
wherever it is legal to use an operand of boolean, numeric, or string type,
respectively.



A constant comparison always yields
an untyped boolean constant.  If the left operand of a constant
shift expression is an untyped constant, the
result is an integer constant; otherwise it is a constant of the same
type as the left operand, which must be of
integer type.



Any other operation on untyped constants results in an untyped constant of the
same kind; that is, a boolean, integer, floating-point, complex, or string
constant.
If the untyped operands of a binary operation (other than a shift) are of
different kinds, the result is of the operand's kind that appears later in this
list: integer, rune, floating-point, complex.
For example, an untyped integer constant divided by an
untyped complex constant yields an untyped complex constant.





Applying the built-in function  to untyped
integer, rune, or floating-point constants yields
an untyped complex constant.





Constant expressions are always evaluated exactly; intermediate values and the
constants themselves may require precision significantly larger than supported
by any predeclared type in the language. The following are legal declarations:





The divisor of a constant division or remainder operation must not be zero:





The values of typed constants must always be accurately
representable by values
of the constant type. The following constant expressions are illegal:





The mask used by the unary bitwise complement operator  matches
the rule for non-constants: the mask is all 1s for unsigned constants
and -1 for signed and untyped constants.





Implementation restriction: A compiler may use rounding while
computing untyped floating-point or complex constant expressions; see
the implementation restriction in the section
on constants.  This rounding may cause a
floating-point constant expression to be invalid in an integer
context, even if it would be integral when calculated using infinite
precision, and vice versa.



Order of evaluation


At package level, initialization dependencies
determine the evaluation order of individual initialization expressions in
variable declarations.
Otherwise, when evaluating the operands of an
expression, assignment, or
return statement,
all function calls, method calls, and
communication operations are evaluated in lexical left-to-right
order.



For example, in the (function-local) assignment



the function calls and communication happen in the order
, , , ,
, , and .
However, the order of those events compared to the evaluation
and indexing of  and the evaluation
of  is not specified.





At package level, initialization dependencies override the left-to-right rule
for individual initialization expressions, but not for operands within each
expression:





The function calls happen in the order
, , ,
, , and .



Floating-point operations within a single expression are evaluated according to
the associativity of the operators.  Explicit parentheses affect the evaluation
by overriding the default associativity.
In the expression  the addition 
is performed before adding .


Statements


Statements control execution.




Terminating statements


A terminating statement prevents execution of all statements that lexically
appear after it in the same block. The following statements
are terminating:




	A "return" or
    	"goto" statement.
	
	 



	A call to the built-in function
	.
	
	 



	A block in which the statement list ends in a terminating statement.
	
	 



	An "if" statement in which:
	
	the "else" branch is present, and
	both branches are terminating statements.
	



	A "for" statement in which:
	
	there are no "break" statements referring to the "for" statement, and
	the loop condition is absent.
	



	A "switch" statement in which:
	
	there are no "break" statements referring to the "switch" statement,
	there is a default case, and
	the statement lists in each case, including the default, end in a terminating
	    statement, or a possibly labeled "fallthrough"
	    statement.
	



	A "select" statement in which:
	
	there are no "break" statements referring to the "select" statement, and
	the statement lists in each case, including the default if present,
	    end in a terminating statement.
	



	A labeled statement labeling
	a terminating statement.




All other statements are not terminating.



A statement list ends in a terminating statement if the list
is not empty and its final non-empty statement is terminating.



Empty statements


The empty statement does nothing.





Labeled statements


A labeled statement may be the target of a ,
 or  statement.







Expression statements


With the exception of specific built-in functions,
function and method calls and
receive operations
can appear in statement context. Such statements may be parenthesized.





The following built-in functions are not permitted in statement context:







Send statements


A send statement sends a value on a channel.
The channel expression must be of channel type,
the channel direction must permit send operations,
and the type of the value to be sent must be assignable
to the channel's element type.





Both the channel and the value expression are evaluated before communication
begins. Communication blocks until the send can proceed.
A send on an unbuffered channel can proceed if a receiver is ready.
A send on a buffered channel can proceed if there is room in the buffer.
A send on a closed channel proceeds by causing a run-time panic.
A send on a  channel blocks forever.





IncDec statements


The "++" and "--" statements increment or decrement their operands
by the untyped constant .
As with an assignment, the operand must be addressable
or a map index expression.





The following assignment statements are semantically
equivalent:





Assignments




Each left-hand side operand must be addressable,
a map index expression, or (for  assignments only) the
blank identifier.
Operands may be parenthesized.





An assignment operation  op
 where op is a binary arithmetic operator
is equivalent to    op
 but evaluates 
only once.  The op construct is a single token.
In assignment operations, both the left- and right-hand expression lists
must contain exactly one single-valued expression, and the left-hand
expression must not be the blank identifier.





A tuple assignment assigns the individual elements of a multi-valued
operation to a list of variables.  There are two forms.  In the
first, the right hand operand is a single multi-valued expression
such as a function call, a channel or
map operation, or a type assertion.
The number of operands on the left
hand side must match the number of values.  For instance, if
 is a function returning two values,





assigns the first value to  and the second to .
In the second form, the number of operands on the left must equal the number
of expressions on the right, each of which must be single-valued, and the
nth expression on the right is assigned to the nth
operand on the left:





The blank identifier provides a way to
ignore right-hand side values in an assignment:





The assignment proceeds in two phases.
First, the operands of index expressions
and pointer indirections
(including implicit pointer indirections in selectors)
on the left and the expressions on the right are all
evaluated in the usual order.
Second, the assignments are carried out in left-to-right order.





In assignments, each value must be assignable
to the type of the operand to which it is assigned, with the following special cases:




	Any typed value may be assigned to the blank identifier.



	If an untyped constant
	is assigned to a variable of interface type or the blank identifier,
	the constant is first implicitly converted to its
	 default type.



	If an untyped boolean value is assigned to a variable of interface type or
	the blank identifier, it is first implicitly converted to type .



If statements


"If" statements specify the conditional execution of two branches
according to the value of a boolean expression.  If the expression
evaluates to true, the "if" branch is executed, otherwise, if
present, the "else" branch is executed.







The expression may be preceded by a simple statement, which
executes before the expression is evaluated.





Switch statements


"Switch" statements provide multi-way execution.
An expression or type specifier is compared to the "cases"
inside the "switch" to determine which branch
to execute.





There are two forms: expression switches and type switches.
In an expression switch, the cases contain expressions that are compared
against the value of the switch expression.
In a type switch, the cases contain types that are compared against the
type of a specially annotated switch expression.
The switch expression is evaluated exactly once in a switch statement.


Expression switches


In an expression switch,
the switch expression is evaluated and
the case expressions, which need not be constants,
are evaluated left-to-right and top-to-bottom; the first one that equals the
switch expression
triggers execution of the statements of the associated case;
the other cases are skipped.
If no case matches and there is a "default" case,
its statements are executed.
There can be at most one default case and it may appear anywhere in the
"switch" statement.
A missing switch expression is equivalent to the boolean value
.





If the switch expression evaluates to an untyped constant, it is first implicitly
converted to its default type;
if it is an untyped boolean value, it is first implicitly converted to type .
The predeclared untyped value  cannot be used as a switch expression.



If a case expression is untyped, it is first implicitly converted
to the type of the switch expression.
For each (possibly converted) case expression  and the value 
of the switch expression,  must be a valid comparison.



In other words, the switch expression is treated as if it were used to declare and
initialize a temporary variable  without explicit type; it is that
value of  against which each case expression  is tested
for equality.



In a case or default clause, the last non-empty statement
may be a (possibly labeled)
"fallthrough" statement to
indicate that control should flow from the end of this clause to
the first statement of the next clause.
Otherwise control flows to the end of the "switch" statement.
A "fallthrough" statement may appear as the last statement of all
but the last clause of an expression switch.



The switch expression may be preceded by a simple statement, which
executes before the expression is evaluated.





Implementation restriction: A compiler may disallow multiple case
expressions evaluating to the same constant.
For instance, the current compilers disallow duplicate integer,
floating point, or string constants in case expressions.


Type switches


A type switch compares types rather than values. It is otherwise similar
to an expression switch. It is marked by a special switch expression that
has the form of a type assertion
using the reserved word  rather than an actual type:





Cases then match actual types  against the dynamic type of the
expression . As with type assertions,  must be of
interface type, and each non-interface type
 listed in a case must implement the type of .
The types listed in the cases of a type switch must all be
different.





The TypeSwitchGuard may include a
short variable declaration.
When that form is used, the variable is declared at the end of the
TypeSwitchCase in the implicit block of each clause.
In clauses with a case listing exactly one type, the variable
has that type; otherwise, the variable has the type of the expression
in the TypeSwitchGuard.



Instead of a type, a case may use the predeclared identifier
;
that case is selected when the expression in the TypeSwitchGuard
is a  interface value.
There may be at most one  case.



Given an expression  of type ,
the following type switch:





could be rewritten:





The type switch guard may be preceded by a simple statement, which
executes before the guard is evaluated.



The "fallthrough" statement is not permitted in a type switch.


For statements


A "for" statement specifies repeated execution of a block. There are three forms:
The iteration may be controlled by a single condition, a "for" clause, or a "range" clause.




For statements with single condition


In its simplest form, a "for" statement specifies the repeated execution of
a block as long as a boolean condition evaluates to true.
The condition is evaluated before each iteration.
If the condition is absent, it is equivalent to the boolean value
.




For statements with  clause


A "for" statement with a ForClause is also controlled by its condition, but
additionally it may specify an init
and a post statement, such as an assignment,
an increment or decrement statement. The init statement may be a
short variable declaration, but the post statement must not.
Variables declared by the init statement are re-used in each iteration.







If non-empty, the init statement is executed once before evaluating the
condition for the first iteration;
the post statement is executed after each execution of the block (and
only if the block was executed).
Any element of the ForClause may be empty but the
semicolons are
required unless there is only a condition.
If the condition is absent, it is equivalent to the boolean value
.




For statements with  clause


A "for" statement with a "range" clause
iterates through all entries of an array, slice, string or map,
or values received on a channel. For each entry it assigns iteration values
to corresponding iteration variables if present and then executes the block.





The expression on the right in the "range" clause is called the range expression,
which may be an array, pointer to an array, slice, string, map, or channel permitting
receive operations.
As with an assignment, if present the operands on the left must be
addressable or map index expressions; they
denote the iteration variables. If the range expression is a channel, at most
one iteration variable is permitted, otherwise there may be up to two.
If the last iteration variable is the blank identifier,
the range clause is equivalent to the same clause without that identifier.



The range expression  is evaluated once before beginning the loop,
with one exception: if at most one iteration variable is present and
 is constant,
the range expression is not evaluated.



Function calls on the left are evaluated once per iteration.
For each iteration, iteration values are produced as follows
if the respective iteration variables are present:






For an array, pointer to array, or slice value , the index iteration
values are produced in increasing order, starting at element index 0.
If at most one iteration variable is present, the range loop produces
iteration values from 0 up to  and does not index into the array
or slice itself. For a  slice, the number of iterations is 0.



For a string value, the "range" clause iterates over the Unicode code points
in the string starting at byte index 0.  On successive iterations, the index value will be the
index of the first byte of successive UTF-8-encoded code points in the string,
and the second value, of type , will be the value of
the corresponding code point.  If the iteration encounters an invalid
UTF-8 sequence, the second value will be ,
the Unicode replacement character, and the next iteration will advance
a single byte in the string.



The iteration order over maps is not specified
and is not guaranteed to be the same from one iteration to the next.
If a map entry that has not yet been reached is removed during iteration,
the corresponding iteration value will not be produced. If a map entry is
created during iteration, that entry may be produced during the iteration or
may be skipped. The choice may vary for each entry created and from one
iteration to the next.
If the map is , the number of iterations is 0.



For channels, the iteration values produced are the successive values sent on
the channel until the channel is closed. If the channel
is , the range expression blocks forever.




The iteration values are assigned to the respective
iteration variables as in an assignment statement.



The iteration variables may be declared by the "range" clause using a form of
short variable declaration
().
In this case their types are set to the types of the respective iteration values
and their scope is the block of the "for"
statement; they are re-used in each iteration.
If the iteration variables are declared outside the "for" statement,
after execution their values will be those of the last iteration.





Go statements


A "go" statement starts the execution of a function call
as an independent concurrent thread of control, or goroutine,
within the same address space.





The expression must be a function or method call; it cannot be parenthesized.
Calls of built-in functions are restricted as for
expression statements.



The function value and parameters are
evaluated as usual
in the calling goroutine, but
unlike with a regular call, program execution does not wait
for the invoked function to complete.
Instead, the function begins executing independently
in a new goroutine.
When the function terminates, its goroutine also terminates.
If the function has any return values, they are discarded when the
function completes.





Select statements


A "select" statement chooses which of a set of possible
send or
receive
operations will proceed.
It looks similar to a
"switch" statement but with the
cases all referring to communication operations.





A case with a RecvStmt may assign the result of a RecvExpr to one or
two variables, which may be declared using a
short variable declaration.
The RecvExpr must be a (possibly parenthesized) receive operation.
There can be at most one default case and it may appear anywhere
in the list of cases.



Execution of a "select" statement proceeds in several steps:




For all the cases in the statement, the channel operands of receive operations
and the channel and right-hand-side expressions of send statements are
evaluated exactly once, in source order, upon entering the "select" statement.
The result is a set of channels to receive from or send to,
and the corresponding values to send.
Any side effects in that evaluation will occur irrespective of which (if any)
communication operation is selected to proceed.
Expressions on the left-hand side of a RecvStmt with a short variable declaration
or assignment are not yet evaluated.



If one or more of the communications can proceed,
a single one that can proceed is chosen via a uniform pseudo-random selection.
Otherwise, if there is a default case, that case is chosen.
If there is no default case, the "select" statement blocks until
at least one of the communications can proceed.



Unless the selected case is the default case, the respective communication
operation is executed.



If the selected case is a RecvStmt with a short variable declaration or
an assignment, the left-hand side expressions are evaluated and the
received value (or values) are assigned.



The statement list of the selected case is executed.




Since communication on  channels can never proceed,
a select with only  channels and no default case blocks forever.





Return statements


A "return" statement in a function  terminates the execution
of , and optionally provides one or more result values.
Any functions deferred by 
are executed before  returns to its caller.





In a function without a result type, a "return" statement must not
specify any result values.




There are three ways to return values from a function with a result
type:



	The return value or values may be explicitly listed
		in the "return" statement. Each expression must be single-valued
		and assignable
		to the corresponding element of the function's result type.

	
	The expression list in the "return" statement may be a single
		call to a multi-valued function. The effect is as if each value
		returned from that function were assigned to a temporary
		variable with the type of the respective value, followed by a
		"return" statement listing these variables, at which point the
		rules of the previous case apply.

	
	The expression list may be empty if the function's result
		type specifies names for its result parameters.
		The result parameters act as ordinary local variables
		and the function may assign values to them as necessary.
		The "return" statement returns the values of these variables.

	



Regardless of how they are declared, all the result values are initialized to
the zero values for their type upon entry to the
function. A "return" statement that specifies results sets the result parameters before
any deferred functions are executed.



Implementation restriction: A compiler may disallow an empty expression list
in a "return" statement if a different entity (constant, type, or variable)
with the same name as a result parameter is in
scope at the place of the return.




Break statements


A "break" statement terminates execution of the innermost
"for",
"switch", or
"select" statement
within the same function.





If there is a label, it must be that of an enclosing
"for", "switch", or "select" statement,
and that is the one whose execution terminates.




Continue statements


A "continue" statement begins the next iteration of the
innermost "for" loop at its post statement.
The "for" loop must be within the same function.





If there is a label, it must be that of an enclosing
"for" statement, and that is the one whose execution
advances.




Goto statements


A "goto" statement transfers control to the statement with the corresponding label
within the same function.







Executing the "goto" statement must not cause any variables to come into
scope that were not already in scope at the point of the goto.
For instance, this example:





is erroneous because the jump to label  skips
the creation of .



A "goto" statement outside a block cannot jump to a label inside that block.
For instance, this example:





is erroneous because the label  is inside
the "for" statement's block but the  is not.


Fallthrough statements


A "fallthrough" statement transfers control to the first statement of the
next case clause in an expression "switch" statement.
It may be used only as the final non-empty statement in such a clause.





Defer statements


A "defer" statement invokes a function whose execution is deferred
to the moment the surrounding function returns, either because the
surrounding function executed a return statement,
reached the end of its function body,
or because the corresponding goroutine is panicking.





The expression must be a function or method call; it cannot be parenthesized.
Calls of built-in functions are restricted as for
expression statements.



Each time a "defer" statement
executes, the function value and parameters to the call are
evaluated as usual
and saved anew but the actual function is not invoked.
Instead, deferred functions are invoked immediately before
the surrounding function returns, in the reverse order
they were deferred. That is, if the surrounding function
returns through an explicit return statement,
deferred functions are executed after any result parameters are set
by that return statement but before the function returns to its caller.
If a deferred function value evaluates
to , execution panics
when the function is invoked, not when the "defer" statement is executed.



For instance, if the deferred function is
a function literal and the surrounding
function has named result parameters that
are in scope within the literal, the deferred function may access and modify
the result parameters before they are returned.
If the deferred function has any return values, they are discarded when
the function completes.
(See also the section on handling panics.)




Built-in functions


Built-in functions are
predeclared.
They are called like any other function but some of them
accept a type instead of an expression as the first argument.



The built-in functions do not have standard Go types,
so they can only appear in call expressions;
they cannot be used as function values.


Close


For a channel , the built-in function 
records that no more values will be sent on the channel.
It is an error if  is a receive-only channel.
Sending to or closing a closed channel causes a run-time panic.
Closing the nil channel also causes a run-time panic.
After calling , and after any previously
sent values have been received, receive operations will return
the zero value for the channel's type without blocking.
The multi-valued receive operation
returns a received value along with an indication of whether the channel is closed.



Length and capacity


The built-in functions  and  take arguments
of various types and return a result of type .
The implementation guarantees that the result always fits into an .





The capacity of a slice is the number of elements for which there is
space allocated in the underlying array.
At any time the following relationship holds:





The length of a  slice, map or channel is 0.
The capacity of a  slice or channel is 0.



The expression  is constant if
 is a string constant. The expressions  and
 are constants if the type of  is an array
or pointer to an array and the expression  does not contain
channel receives or (non-constant)
function calls; in this case  is not evaluated.
Otherwise, invocations of  and  are not
constant and  is evaluated.




Allocation


The built-in function  takes a type ,
allocates storage for a variable of that type
at run time, and returns a value of type 
pointing to it.
The variable is initialized as described in the section on
initial values.





For instance





allocates storage for a variable of type ,
initializes it (, ),
and returns a value of type  containing the address
of the location.


Making slices, maps and channels


The built-in function  takes a type ,
which must be a slice, map or channel type,
optionally followed by a type-specific list of expressions.
It returns a value of type  (not ).
The memory is initialized as described in the section on
initial values.






Each of the size arguments  and  must be of integer type
or an untyped constant.
A constant size argument must be non-negative and representable
by a value of type ; if it is an untyped constant it is given type .
If both  and  are provided and are constant, then
 must be no larger than .
If  is negative or larger than  at run time,
a run-time panic occurs.





Calling  with a map type and size hint  will
create a map with initial space to hold  map elements.
The precise behavior is implementation-dependent.



Appending to and copying slices


The built-in functions  and  assist in
common slice operations.
For both functions, the result is independent of whether the memory referenced
by the arguments overlaps.



The variadic function 
appends zero or more values 
to  of type , which must be a slice type, and
returns the resulting slice, also of type .
The values  are passed to a parameter of type 
where  is the element type of
 and the respective
parameter passing rules apply.
As a special case,  also accepts a first argument
assignable to type  with a second argument of
string type followed by . This form appends the
bytes of the string.





If the capacity of  is not large enough to fit the additional
values,  allocates a new, sufficiently large underlying
array that fits both the existing slice elements and the additional values.
Otherwise,  re-uses the underlying array.





The function  copies slice elements from
a source  to a destination  and returns the
number of elements copied.
Both arguments must have identical element type  and must be
assignable to a slice of type .
The number of elements copied is the minimum of
 and .
As a special case,  also accepts a destination argument assignable
to type  with a source argument of a string type.
This form copies the bytes from the string into the byte slice.





Examples:





Deletion of map elements


The built-in function  removes the element with key
 from a map . The
type of  must be assignable
to the key type of .





If the map  is  or the element 
does not exist,  is a no-op.



Manipulating complex numbers


Three functions assemble and disassemble complex numbers.
The built-in function  constructs a complex
value from a floating-point real and imaginary part, while
 and 
extract the real and imaginary parts of a complex value.





The type of the arguments and return value correspond.
For , the two arguments must be of the same
floating-point type and the return type is the complex type
with the corresponding floating-point constituents:
 for  arguments, and
 for  arguments.
If one of the arguments evaluates to an untyped constant, it is first implicitly
converted to the type of the other argument.
If both arguments evaluate to untyped constants, they must be non-complex
numbers or their imaginary parts must be zero, and the return value of
the function is an untyped complex constant.



For  and , the argument must be
of complex type, and the return type is the corresponding floating-point
type:  for a  argument, and
 for a  argument.
If the argument evaluates to an untyped constant, it must be a number,
and the return value of the function is an untyped floating-point constant.



The  and  functions together form the inverse of
, so for a value  of a complex type ,
.



If the operands of these functions are all constants, the return
value is a constant.




Handling panics

 Two built-in functions,  and ,
assist in reporting and handling run-time panics
and program-defined error conditions.





While executing a function ,
an explicit call to  or a run-time panic
terminates the execution of .
Any functions deferred by 
are then executed as usual.
Next, any deferred functions run by  caller are run,
and so on up to any deferred by the top-level function in the executing goroutine.
At that point, the program is terminated and the error
condition is reported, including the value of the argument to .
This termination sequence is called panicking.





The  function allows a program to manage behavior
of a panicking goroutine.
Suppose a function  defers a function  that calls
 and a panic occurs in a function on the same goroutine in which 
is executing.
When the running of deferred functions reaches ,
the return value of 's call to  will be the value passed to the call of .
If  returns normally, without starting a new
, the panicking sequence stops. In that case,
the state of functions called between  and the call to 
is discarded, and normal execution resumes.
Any functions deferred by  before  are then run and 's
execution terminates by returning to its caller.



The return value of  is  if any of the following conditions holds:



's argument was ;


the goroutine is not panicking;


 was not called directly by a deferred function.




The  function in the example below invokes
the function argument  and protects callers from
run-time panics raised by .





Bootstrapping


Current implementations provide several built-in functions useful during
bootstrapping. These functions are documented for completeness but are not
guaranteed to stay in the language. They do not return a result.





Implementation restriction:  and  need not
accept arbitrary argument types, but printing of boolean, numeric, and string
types must be supported.


Packages


Go programs are constructed by linking together packages.
A package in turn is constructed from one or more source files
that together declare constants, types, variables and functions
belonging to the package and which are accessible in all files
of the same package. Those elements may be
exported and used in another package.


Source file organization


Each source file consists of a package clause defining the package
to which it belongs, followed by a possibly empty set of import
declarations that declare packages whose contents it wishes to use,
followed by a possibly empty set of declarations of functions,
types, variables, and constants.




Package clause


A package clause begins each source file and defines the package
to which the file belongs.





The PackageName must not be the blank identifier.





A set of files sharing the same PackageName form the implementation of a package.
An implementation may require that all source files for a package inhabit the same directory.


Import declarations


An import declaration states that the source file containing the declaration
depends on functionality of the imported package
(§Program initialization and execution)
and enables access to exported identifiers
of that package.
The import names an identifier (PackageName) to be used for access and an ImportPath
that specifies the package to be imported.





The PackageName is used in qualified identifiers
to access exported identifiers of the package within the importing source file.
It is declared in the file block.
If the PackageName is omitted, it defaults to the identifier specified in the
package clause of the imported package.
If an explicit period () appears instead of a name, all the
package's exported identifiers declared in that package's
package block will be declared in the importing source
file's file block and must be accessed without a qualifier.



The interpretation of the ImportPath is implementation-dependent but
it is typically a substring of the full file name of the compiled
package and may be relative to a repository of installed packages.



Implementation restriction: A compiler may restrict ImportPaths to
non-empty strings using only characters belonging to
Unicode's
L, M, N, P, and S general categories (the Graphic characters without
spaces) and may also exclude the characters

and the Unicode replacement character U+FFFD.



Assume we have compiled a package containing the package clause
, which exports function , and
installed the compiled package in the file identified by
.
This table illustrates how  is accessed in files
that import the package after the
various types of import declaration.





An import declaration declares a dependency relation between
the importing and imported package.
It is illegal for a package to import itself, directly or indirectly,
or to directly import a package without
referring to any of its exported identifiers. To import a package solely for
its side-effects (initialization), use the blank
identifier as explicit package name:





An example package


Here is a complete Go package that implements a concurrent prime sieve.




Program initialization and execution

The zero value

When storage is allocated for a variable,
either through a declaration or a call of , or when
a new value is created, either through a composite literal or a call
of ,
and no explicit initialization is provided, the variable or value is
given a default value.  Each element of such a variable or value is
set to the zero value for its type:  for booleans,
 for numeric types, 
for strings, and  for pointers, functions, interfaces, slices, channels, and maps.
This initialization is done recursively, so for instance each element of an
array of structs will have its fields zeroed if no value is specified.


These two simple declarations are equivalent:





After





the following holds:





The same would also be true after




Package initialization


Within a package, package-level variable initialization proceeds stepwise,
with each step selecting the variable earliest in declaration order
which has no dependencies on uninitialized variables.



More precisely, a package-level variable is considered ready for
initialization if it is not yet initialized and either has
no initialization expression or
its initialization expression has no dependencies on uninitialized variables.
Initialization proceeds by repeatedly initializing the next package-level
variable that is earliest in declaration order and ready for initialization,
until there are no variables ready for initialization.



If any variables are still uninitialized when this
process ends, those variables are part of one or more initialization cycles,
and the program is not valid.



Multiple variables on the left-hand side of a variable declaration initialized
by single (multi-valued) expression on the right-hand side are initialized
together: If any of the variables on the left-hand side is initialized, all
those variables are initialized in the same step.





For the purpose of package initialization, blank
variables are treated like any other variables in declarations.



The declaration order of variables declared in multiple files is determined
by the order in which the files are presented to the compiler: Variables
declared in the first file are declared before any of the variables declared
in the second file, and so on.



Dependency analysis does not rely on the actual values of the
variables, only on lexical references to them in the source,
analyzed transitively. For instance, if a variable 's
initialization expression refers to a function whose body refers to
variable  then  depends on .
Specifically:




A reference to a variable or function is an identifier denoting that
variable or function.



A reference to a method  is a
method value or
method expression of the form
, where the (static) type of  is
not an interface type, and the method  is in the
method set of .
It is immaterial whether the resulting function value
 is invoked.



A variable, function, or method  depends on a variable
 if 's initialization expression or body
(for functions and methods) contains a reference to 
or to a function or method that depends on .




For example, given the declarations





the initialization order is , , , .
Note that the order of subexpressions in initialization expressions is irrelevant:
 and  result in the same initialization
order in this example.



Dependency analysis is performed per package; only references referring
to variables, functions, and (non-interface) methods declared in the current
package are considered. If other, hidden, data dependencies exists between
variables, the initialization order between those variables is unspecified.



For instance, given the declarations





the variable  will be initialized after  but
whether  is initialized before , between
 and , or after , and
thus also the moment at which  is called (before
or after  is initialized) is not specified.



Variables may also be initialized using functions named 
declared in the package block, with no arguments and no result parameters.





Multiple such functions may be defined per package, even within a single
source file. In the package block, the  identifier can
be used only to declare  functions, yet the identifier
itself is not declared. Thus
 functions cannot be referred to from anywhere
in a program.



A package with no imports is initialized by assigning initial values
to all its package-level variables followed by calling all 
functions in the order they appear in the source, possibly in multiple files,
as presented to the compiler.
If a package has imports, the imported packages are initialized
before initializing the package itself. If multiple packages import
a package, the imported package will be initialized only once.
The importing of packages, by construction, guarantees that there
can be no cyclic initialization dependencies.



Package initialization—variable initialization and the invocation of
 functions—happens in a single goroutine,
sequentially, one package at a time.
An  function may launch other goroutines, which can run
concurrently with the initialization code. However, initialization
always sequences
the  functions: it will not invoke the next one
until the previous one has returned.



To ensure reproducible initialization behavior, build systems are encouraged
to present multiple files belonging to the same package in lexical file name
order to a compiler.



Program execution

A complete program is created by linking a single, unimported package
called the main package with all the packages it imports, transitively.
The main package must
have package name  and
declare a function  that takes no
arguments and returns no value.





Program execution begins by initializing the main package and then
invoking the function .
When that function invocation returns, the program exits.
It does not wait for other (non-) goroutines to complete.


Errors


The predeclared type  is defined as





It is the conventional interface for representing an error condition,
with the nil value representing no error.
For instance, a function to read data from a file might be defined:




Run-time panics


Execution errors such as attempting to index an array out
of bounds trigger a run-time panic equivalent to a call of
the built-in function 
with a value of the implementation-defined interface type .
That type satisfies the predeclared interface type
.
The exact error values that
represent distinct run-time error conditions are unspecified.




System considerations

Package 


The built-in package , known to the compiler
and accessible through the import path ,
provides facilities for low-level programming including operations
that violate the type system. A package using 
must be vetted manually for type safety and may not be portable.
The package provides the following interface:





A  is a pointer type but a 
value may not be dereferenced.
Any pointer or value of underlying type  can be converted to
a type of underlying type  and vice versa.
The effect of converting between  and  is implementation-defined.





The functions  and  take an expression 
of any type and return the alignment or size, respectively, of a hypothetical variable 
as if  was declared via .


The function  takes a (possibly parenthesized) selector
, denoting a field  of the struct denoted by 
or , and returns the field offset in bytes relative to the struct's address.
If  is an embedded field, it must be reachable
without pointer indirections through fields of the struct.
For a struct  with field :





Computer architectures may require memory addresses to be aligned;
that is, for addresses of a variable to be a multiple of a factor,
the variable's type's alignment.  The function 
takes an expression denoting a variable of any type and returns the
alignment of the (type of the) variable in bytes.  For a variable
:





Calls to , , and
 are compile-time constant expressions of type .


Size and alignment guarantees


For the numeric types, the following sizes are guaranteed:





The following minimal alignment properties are guaranteed:


For a variable  of any type:  is at least 1.


For a variable  of struct type:  is the largest of
   all the values  for each field  of , but at least 1.


For a variable  of array type:  is the same as
	the alignment of a variable of the array's element type.




A struct or array type has size zero if it contains no fields (or elements, respectively) that have a size greater than zero. Two distinct zero-size variables may have the same address in memory.




